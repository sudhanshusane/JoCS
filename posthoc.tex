We build two parallelize-over-data distributed-memory \textit{post hoc} interpolation pipelines, one for each: Lagrangian and Eulerian.
%
%To calculate pathlines using the Lagrangian data post hoc, a particle $p$ identifies a neighborhood of basis flows to follow.
%
%A neighborhood is the convex hull that contains the location of the $p$.
%
For the Lagrangian \textbf{PHE} we construct a search structure in the form of a Delaunay triagulation over the start locations of valid basis particles using CGAL~\cite{fabri2011cgal} to identify particle neighborhoods.
%We calculate the Delaunay triangulation over all the start locations of valid basis flows using CGAL~\cite{fabri2011cgal}.
%
%Thus, we locate particle neighborhoods by identifying the containing cell in the Delaunay triangulation. 
%
%We choose to use a reconstruction method that can operate on structured, as well as unstructured data, because Lagrangian representations can take many forms.
%
%Use of a method that supports unstructured input, i.e., the basis particles are not initialized along a uniform grid, provides a better representation of the general post hoc reconstruction case.
%
%The most straightforward, albeit expensive, approach is to calculate a global Delaunay triangulation.
%
%However, a global Delaunay triangulation can get prohibitively expensive as the total number of particles increases.
%
%A second approach is to perform spatial binning followed by a smaller more local Delaunay triangulation.
%
%However, this method requires an expanding search structure in addition to a binning scheme to guarantee a particle locates a neighborhood if available.
%
%Further, the cost of calculating a local Delaunay triangulation for each particle would be dependent on the number of particles.
%
In our implementation, each rank loads basis particles of the rank itself as well as basis particles generated by spatially adjacent ranks (i.e., upto 27 ranks for a rectilinear simulation grid).
%
%Thus, each post hoc interpolation rank loads data from upto 27 ranks.
%
%The Delaunay triangulation is then performed for all the valid basis flows in the loaded data.
%
%Although not optimal, this approach will scale better than a global Delaunary triangulation while remaining straightforward.
%
%The best approach to identify a particle neighborhood in a large distributed memory settings with a large number of particles remains an open research problem and is beyond the scope of this work. 
%
Once a particle neighborhood is identified, barycentric coordinate interpolation is used to calculate the displacement of $p$.  
%
%If a particle enters the domain bounds of an adjacent node it is communicate to the rank corresponding to that domain using MPI. 
%
Our implementation uses MPI to communicate particles across ranks and continue the integration of trajectories across node boundaries.

For the Eulerian \textit{post hoc} interpolation pipeline, we use the VTK-m particle advection infrastructure to perform RK4 integration and MPI for communication of particles across ranks.
%
%In this pipeline, each rank is only required to load the velocity field stored to disk for that particular rank.
